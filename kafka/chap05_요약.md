# 5장  프로듀서의 내부 동작 원리와 구현 요약

## 🔑 왜 파티셔너가 필요한가?
- Kafka는 하나의 토픽을 여러 파티션으로 나누어 병렬성과 확장성을 높임.
- 프로듀서가 메시지를 전송할 때 어떤 파티션으로 보낼지 결정하는 역할이 바로 파티셔너!
- 같은 키를 가진 메시지를 같은 파티션에 보내면 메시지 순서를 보장할 수 있음.

## 🗂️ 파티셔너 동작 원리
- 메시지가 키를 포함하면 → 해시(Hash) 값 계산 → 파티션 번호 결정
- 메시지에 키가 없으면 → 라운드 로빈(Round Robin) 방식으로 파티션 분배

## ✅ 라운드 로빈 vs 스티키 파티셔너
| 구분 |	라운드 로빈	| 스티키 파티셔너 |
| -- |	--	| -- |
| 동작 |	키가 없으면 파티션을 순서대로 순환	| 하나의 파티션에 묶어 보내다 배치가 차면 다른 파티션으로 이동
| 장점	| 분산 균등화	| 배치 효율 극대화 (I/O 비용 절감)
| Kafka 기본값 |	과거 기본	| Kafka 2.4 이상 기본값
- 스티키(Sticky) 방식은 소량 메시지라도 한 파티션에 몰아 보내면서 배치 사이즈를 키워 네트워크 비용 절감 가능.
- 대량 트래픽일수록 스티키 파티셔너 효과가 큼.

## 🗂️ 파티셔너 관련 실무 포인트
- 동일한 키를 갖는 메시지는 반드시 같은 파티션에 가야 순서 유지됨 → 키 설계 중요!
- 파티션 수를 변경하면 해시 테이블이 바뀌어 → 동일 키라도 다른 파티션으로 갈 수 있음 → 데이터 순서 꼬임 주의.
- 파티션 수는 최대한 처음에 확장성을 고려해 설계.

# 📌 5.2 프로듀서의 배치(Batching)
## 🔑 왜 배치가 중요한가?
- Kafka는 고성능 처리 시스템 → 메시지를 하나씩 보내면 I/O 비용 폭발!
- 프로듀서는 메시지를 메모리 버퍼에 모았다가 일정 단위로 묶어 한 번에 전송 → 처리량(Throughput) 극대화.

## 🗂️ 배치 동작 흐름
### 버퍼 메모리(buffer.memory)
- 프로듀서가 메시지를 임시 저장하는 공간. 기본값은 32MB.
- 파티션별로 여러 배치가 동작할 수 있음.
- 배치 크기(batch.size)
- 한 번에 묶어서 보내는 메시지 양. 기본 16KB.
- 너무 작으면 배치 효과 ↓, 너무 크면 메모리 부족 → 조정 필요.

### 지연 시간(linger.ms)
- 배치가 꽉 차지 않더라도 최대 대기 시간이 지나면 바로 전송.
- 기본값 0ms → 즉시 전송. 일반적으로 5~10ms로 잡아 네트워크 효율 ↑.

### ✅ 배치와 스티키 파티셔너 궁합
- 스티키 파티셔너는 하나의 파티션에 메시지를 몰아 넣음 → 배치가 빨리 차기 때문에 처리 효율 ↑.
- 여러 파티션에 메시지가 분산되면 배치가 찔끔찔끔 쌓여 효율 ↓.

# 📌 5.3 압축(Compression)
### 🔑 왜 압축을 쓰나?
- 메시지를 네트워크로 전송할 때 I/O 부하를 줄이기 위해.
- Kafka는 레코드셋 단위로 압축.
- 지원 코덱: gzip, snappy, lz4, zstd.

## ✅ 압축 실무 팁
- gzip은 압축률 좋지만 CPU 부하 ↑
- lz4나 zstd는 압축 속도가 빠르고 실무에서 많이 사용.
- 프로듀서/브로커/컨슈머 모두 동일 압축 코덱을 지원해야 함.

# 📌 5.4 중복 없는 전송 (Idempotence)
## 🔑 Kafka 기본은 ‘적어도 한 번(at least once)’ 전송
- ACK 못 받으면 재전송 → 중복 가능성 존재.

## 🗂️ 중복 없는 전송 개념
- Kafka 0.11부터 Idempotent Producer 지원 → PID(Producer ID)와 Sequence Number로 중복 메시지 제거.
- 팔로워가 리더로 승격되더라도 PID + 시퀀스 정보로 중복 확인.

## ✅ 중복 없는 전송 실무 설정
- enable.idempotence=true
- acks=all (모든 ISR에 복제 성공해야 ACK 반환)
- max.in.flight.requests.per.connection <= 5 (동시 전송 제한)
- retries는 무제한(또는 큰 값)

### 📌 5.5 정확히 한 번 전송 (Exactly-once)
## 🔑 Idempotence + 트랜잭션 → Exactly-once
- 멱등성만 있으면 Producer 중복은 막지만 컨슈머에선 중복 읽힐 수 있음.
- 컨슈머와 함께 트랜잭션 처리를 연계하면 “읽고-쓰기” 모두 한번만 처리됨.

## 🗂️ 트랜잭션 처리 흐름
- Producer 트랜잭션 시작 → initTransactions(), beginTransaction()
- 메시지 전송
- 컨슈머 오프셋도 트랜잭션에 포함 → sendOffsetsToTransaction()
- 트랜잭션 커밋 or 어보트 → commitTransaction(), abortTransaction()
- 중간에 실패해도 Kafka가 트랜잭션 로그로 상태 관리 → 중복/누락 없이 일관성 유지.
