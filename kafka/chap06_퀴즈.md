# 📚 Kafka 컨슈머 동작 원리 실습 퀴즈



## ✅ 객관식 10문제



**1. Kafka 컨슈머의 오프셋 관리에 대한 설명으로 옳지 않은 것은?**

- A. 오프셋은 `_consumer_offsets`라는 내부 토픽에 저장된다.
- B. 오프셋 정보는 컨슈머 그룹 단위로만 관리된다.
- C. 장애 시 마지막 저장된 오프셋부터 이어서 메시지를 읽을 수 있다.
- D. 오프셋은 수동으로 기록할 수 없다.

**정답:** B, D
- B는 일부 컨슈머가 커밋하지 않고 수동으로 관리할 수도 있어 컨슈머 그룹 단위로만 제한되지 않습니다.
- D는 Kafka에서 commitSync(), commitAsync()로 수동 커밋이 가능하므로 틀렸습니다.


**2. 그룹 코디네이터의 역할로 알맞은 것을 모두 고르시오.**

- A. 파티션 할당 관리
- B. 멤버 상태 유지 및 변경 감지
- C. 메시지 생산(Producer) 작업 수행
- D. 리밸런싱 트리거

**정답:** A, B, D
- 그룹 코디네이터는 컨슈머 그룹 내 멤버 관리를 하고 리밸런싱도 주관하지만, Producer 작업은 수행하지 않습니다.


**3. 컨슈머와 그룹 코디네이터가 상태를 확인하기 위해 주기적으로 사용하는 것은?**

- A. 세션 타임아웃
- B. 하트비트
- C. 리밸런싱 딜레이
- D. 트랜잭션 ID

**정답:** B
- 컨슈머는 그룹 코디네이터에 하트비트를 주기적으로 보내 세션 유지 여부를 확인합니다.


**4. 컨슈머 그룹의 리밸런싱이 자주 일어나는 것을 방지하기 위한 방법으로 옳은 것은?**

- A. 하트비트 주기 최소화
- B. 스태틱 멤버십 사용
- C. Cooperative Sticky 할당 전략 사용
- D. EAGER 리밸런싱 사용

**정답:** B, C
- 스태틱 멤버십과 Cooperative Sticky 할당 전략은 불필요한 전체 리밸런싱을 줄여 안정성을 높입니다.
- EAGER는 오히려 파티션을 한 번에 재할당해 중지 시간이 더 길어집니다.


**5. 아래 중 Round-Robin 할당 전략의 특징으로 알맞은 것을 모두 고르시오.**

- A. 파티션을 순서대로 나열해 순차적으로 할당한다.
- B. 일부 컨슈머에 파티션이 몰릴 수 있다.
- C. 균등 분배에 유리하다.
- D. 리밸런싱 시 기존 파티션 유지에 집중한다.

**정답:** A, C
- Round-Robin은 파티션을 순차적으로 나열하고 고르게 분배하려는 방식입니다.
- 기존 파티션 유지보다는 균등성이 우선이므로 D는 틀렸습니다.

**6. Sticky 파티션 할당 전략의 주된 목적은?**

- A. 파티션을 완전히 새로 할당한다.
- B. 기존 할당을 최대한 유지한다.
- C. 컨슈머 수에 따라 파티션을 무작위 분배한다.
- D. 하트비트 주기를 줄인다.

**정답:** B
- Sticky 전략은 리밸런싱 시 기존 파티션 할당을 최대한 유지해 불필요한 데이터 이동을 최소화합니다.


**7. `_consumer_offsets` 토픽의 기본 파티션 수와 복제 수에 대한 설명으로 옳은 것은?**

- A. 파티션 수 기본 50, 복제 수 기본 3이다.
- B. 기본값은 변경할 수 없다.
- C. server.properties에서 조정할 수 있다.
- D. 이 값은 하드코딩 되어 고정이다.

**정답:** A, C
- 기본은 파티션 50개, 복제 3개로 시작하며, server.properties 파일에서 값을 수정할 수 있습니다.


**8. 스태틱 멤버십 설정을 위해 사용되는 Kafka 설정 값은?**

- A. group.instance.id
- B. offsets.topic.num.partitions
- C. session.timeout.ms
- D. enable.idempotence

**정답:** A
- 스태틱 멤버십을 위해서는 컨슈머가 group.instance.id를 고정해 리밸런싱 시에도 멤버 ID를 유지합니다.


**9. 정확히 한 번 컨슈머 동작과 관련하여 필요한 것은?**

- A. 트랜잭션 ID 사용
- B. 하트비트 생략
- C. 오프셋 커밋 시점 관리
- D. EAGER 리밸런싱 강제 적용

**정답:** A, C
- 컨슈머도 Exactly-once를 위해선 트랜잭션 ID로 생산/소비/커밋을 묶어야 하며, 커밋 시점을 잘 관리해야 중복 처리를 방지할 수 있습니다.


**10. Cooperative Sticky 전략의 장점으로 올바른 것은?**

- A. 모든 파티션을 한 번에 재할당한다.
- B. 일부 파티션만 재할당하여 불필요한 중지 최소화
- C. EAGER보다 리밸런싱 비용이 높다.
- D. 스태틱 멤버십과 함께 사용 가능하다.

**정답:** B, D
- Cooperative Sticky는 파티션을 필요한 부분만 점진적으로 재할당해 리밸런싱 중지 비용을 최소화하고, 스태틱 멤버십과 함께 사용하면 더욱 안정적입니다.


## ✅ 주관식 5문제



**1. 컨슈머 그룹에서 리밸런싱이 발생하는 두 가지 주요 상황을 쓰시오.**

**정답:**  
- 컨슈머가 추가되거나 제거될 때  
- 그룹 내 파티션 수나 구성에 변화가 있을 때

**2. 스태틱 멤버십(static membership)을 사용할 때 리밸런싱이 자주 발생하지 않는 이유를 설명하시오.**

**정답:**  
- 컨슈머가 재시작하더라도 동일한 `group.instance.id`를 사용해 기존 멤버로 인식되기 때문에 불필요한 재할당이 일어나지 않는다.

**3. 하트비트(heartbeat)의 역할과 연관 설정 옵션 2가지를 쓰시오.**

**정답:**  
- 역할: 컨슈머가 정상인지 그룹 코디네이터에게 주기적으로 상태를 알림.  
- 관련 설정: `heartbeat.interval.ms`, `session.timeout.ms`



**4. Cooperative Sticky와 기존 EAGER 리밸런싱의 차이점을 간략히 쓰시오.**

**정답:**  
- Cooperative Sticky는 일부 파티션만 단계적으로 재할당해 중단 시간을 최소화한다.  
- EAGER는 모든 파티션을 한 번에 재할당해 중단 비용이 더 크다.



**5. 정확히 한 번 전송(Exactly Once)과 정확히 한 번 읽기(Exactly Once Delivery)의 핵심 차이를 쓰시오.**

**정답:**  
- 전송: 프로듀서가 트랜잭션을 사용해 메시지를 중복 없이 전송.  
- 읽기: 컨슈머가 메시지를 중복 처리하지 않도록 오프셋을 commit 시점과 함께 관리.
