📌 핵심 요약
✅ 6.1 컨슈머 오프셋 관리
컨슈머의 핵심은 오프셋(offset) 관리.

컨슈머는 Kafka에서 메시지를 읽은 위치를 _consumer_offsets라는 내부 토픽에 저장.

만약 컨슈머가 재시작되면 마지막으로 읽은 오프셋부터 다시 시작 가능.

컨슈머 그룹은 토픽 파티션을 나눠서 읽으며 그룹 단위로 오프셋 관리.

✅ 6.2 그룹 코디네이터
컨슈머 그룹의 안정적인 동작을 위해 **그룹 코디네이터(group coordinator)**가 존재.

코디네이터는 그룹의 파티션과 멤버 변화를 트래킹(tracking)하고, 재밸런싱을 관리.

컨슈머가 그룹에 처음 접속할 때 리더 컨슈머를 선출해 코디네이터와 연결.

코디네이터가 파티션 할당을 결정해 컨슈머에 전달.

✅ 컨슈머 그룹 등록과정
컨슈머는 bootstrap.brokers로 브로커에 연결 → 그룹 코디네이터에 등록 요청 → 코디네이터가 파티션 할당 → 각 컨슈머는 할당된 파티션에서 메시지 읽음.

Heartbeat로 컨슈머 상태를 주기적으로 코디네이터에 전달하여 장애를 감지.

✅ 6.3 스태틱 멤버십
컨슈머가 재시작될 때마다 매번 리밸런싱이 일어나면 비용이 크므로 Kafka 2.3+에서는 스태틱 멤버십(static membership) 기능 제공.

컨슈머에 고유한 group.instance.id를 부여해 재시작 시 기존 멤버로 인식.

이를 통해 불필요한 리밸런싱을 방지.

📌 핵심 옵션
heartbeat.interval.ms : 컨슈머가 코디네이터에 상태를 주기적으로 알리는 간격.

session.timeout.ms : Heartbeat 신호를 못 받으면 실패로 간주할 시간.

max.poll.interval.ms : poll() 호출 간격 제한. 너무 길면 실패로 간주.

📌 실습 흐름 요약
✅ 1) 컨슈머 표준 실행 흐름
consumer_standard.py 와 producer.py를 이용해 메시지를 전송하고 읽음.

출력 예시에서 Partition, Offset, Received message로 소비된 메시지 확인.

kafka-consumer-groups.sh 명령어로 각 파티션별 현재 오프셋, 끝 오프셋(Log-End-Offset), LAG 상태를 확인.

그림 6-4와 그림 6-5는 컨슈머가 종료되면서 리밸런싱이 일어나 파티션이 다시 분배되는 과정을 시각화.

✅ 2) 리밸런싱 동작 이해
컨슈머 종료 → 그룹 코디네이터가 감지 → 남은 컨슈머에 파티션 재할당.

그림 6-4: 정상 동작 시 파티션이 고르게 분배.

그림 6-5: 컨슈머 하나 종료 시 다른 컨슈머가 파티션을 추가 담당 → 리밸런싱 발생.

이를 통해 불필요한 리밸런싱이 시스템 부하가 큼을 이해.

✅ 3) 스태틱 멤버십 적용
consumer_static.py 예시로 group.instance.id를 설정해 고유 ID 유지.

표준 컨슈머와 달리 재시작해도 리밸런싱이 불필요.

그림 6-6과 그림 6-7은 스태틱 멤버십 적용 시 리밸런싱이 발생하지 않는 모습을 보여줌.

session.timeout.ms를 짧게(예: 30초) 설정해 컨슈머 장애 상황 시 리밸런싱 발생 여부 실험 가능.

✅ 4) 명령어 흐름 핵심
python producer.py → 메시지 전송.

python consumer_standard.py → 표준 컨슈머 실행.

python consumer_static.py → 스태틱 멤버십 컨슈머 실행.

kafka-consumer-groups.sh --describe → 그룹 상태, 오프셋, LAG 확인.

deactivate → 가상환경 종료.

🔑 핵심 포인트
컨슈머 그룹은 리밸런싱 발생 시 잠시 메시지 소비가 중단됨.

스태틱 멤버십은 불필요한 리밸런싱 방지로 안정성 향상.

group.instance.id를 사용해 컨슈머 재시작 시 동일 ID로 인식되도록 설정.

✅ 6.4 컨슈머 파티션 할당 전략 요약
Kafka에서는 컨슈머 그룹 리더가 구독 중인 토픽의 파티션을 각 컨슈머에게 어떻게 나눌지 결정할 때 4가지 전략을 선택할 수 있어요.

📌 1) Range Assigner (레인지 할당)
방식: 토픽별 파티션을 순서대로 정렬 후 컨슈머 수에 따라 연속 구간으로 나누어 할당.

특징: 특정 컨슈머가 일부 파티션만 연속으로 담당 → 여러 토픽 조합 시 불균형 가능.

장점/단점: 단일 토픽에선 단순하고 효율적, 다중 토픽에서는 불균형 주의.

📌 2) Round Robin Assigner (라운드 로빈 할당)
방식: 전체 파티션들을 하나의 리스트로 만들어 순서대로 컨슈머에게 돌아가며 할당.

특징: 여러 토픽에서도 균등 분배 용이.

예시: 그림 6-9와 표 6-2처럼 파티션 순서가 컨슈머1, 컨슈머2, 컨슈머1, 컨슈머2 순으로 돌아가며 매핑됨.

📌 3) Sticky Assigner (스티키 할당)
방식: 파티션 할당 시 최대한 이전 할당 관계 유지.

목적: 리밸런싱 시에도 불필요한 데이터 이동 최소화.

예시: 그림 6-10과 6-12에서 컨슈머2가 장애로 제외돼도 나머지 컨슈머의 파티션 소유권은 최대한 유지.

📌 4) Cooperative Sticky Assigner (협력적 스티키 할당)
방식: Sticky와 유사하지만 파티션 이동을 점진적·부분적으로 수행 → 전체 리밸런싱의 일시적 중단 최소화.

핵심: EAGER 리밸런싱 프로토콜 대신, 점진적 파티션 이동으로 다운타임(LAG) 최소화.

예시: 그림 6-13은 일반 리밸런싱의 감지-중지-재시작 단계를 설명해 cooperative 방식의 장점을 보여줌.

✅ ⚙️ 리밸런싱 동작과의 관계
Range/라운드 로빈: 파티션을 새로 배분하기 때문에 리밸런싱 시 모든 컨슈머 파티션 매핑이 변할 수 있음.

Sticky/Cooperative Sticky: 파티션 소유권 최대 유지, 데이터 이동 최소화 → 불필요한 리밸런싱 방지.

✅ 📊 그림과 표 핵심 정리
표 6-1, 6-2, 6-3: 각 전략별 할당 규칙과 매핑 예시.

그림 6-8 ~ 6-13: 파티션 할당의 흐름과 컨슈머 장애 시 리밸런싱 변화 비교.

특히 그림 6-11과 6-12는 컨슈머 장애 후 round robin vs sticky의 차이를 한눈에 보여줌.

🔑 요약 포인트
리밸런싱은 메시지 처리 지연의 주요 원인!

다중 토픽/파티션 환경에선 Sticky/Cooperative Sticky 전략을 권장.

session.timeout.ms와 함께 리밸런싱 빈도 관리 중요.

✅ 📌 협력적(Cooperative) 스티키 리밸런싱 요약
📍 왜 필요한가?
기존 EAGER 리밸런싱은 파티션 소유권 변경이 있으면 전체 컨슈머 그룹이 동시에 리밸런싱 → 일시적 메시지 소비 중단(LAG 증가).

특히 대규모 컨슈머 그룹은 리밸런싱 비용이 큼.

이를 개선하려고 Kafka 2.4 버전부터 협력적(Cooperative) 스티키 리밸런싱 지원.

📍 동작 방식 (그림 6-14)
1️⃣ 감지 단계: 새로운 컨슈머가 그룹에 조인하면 리밸런싱 트리거.
2️⃣ 첫 번째 리밸런싱: 기존 멤버들의 파티션 정보를 리더가 받아, 변경해야 할 파티션 결정.
3️⃣ 두 번째 리밸런싱: 제외된 파티션을 재할당 → 필요한 부분만 점진적으로 이동.

그림 6-14는 3단계 과정을 명확히 보여줌:

기존 컨슈머(peter-kafka02, kafka03)가 소유하고 있던 파티션.

새로운 컨슈머(peter-kafka01)가 합류하면서 파티션 일부만 점진적으로 재분배.

불필요한 전체 리밸런싱 방지 → 메시지 소비 중단 최소화.

📍 COOPERATIVE vs EAGER
EAGER: 파티션 소유권 변경 있으면 전체 그룹의 파티션 할당 모두 제거 → 다운타임 큼.

COOPERATIVE: 일부 파티션만 부분적으로 이동 → 다운타임 최소화.

Kafka 2.5 버전부터 기본 적용, 최신 버전에서도 권장됨.

✅ 📌 장점
✔️ 메시지 LAG 최소화
✔️ 큰 컨슈머 그룹에서도 효율적
✔️ EAGER 대비 리밸런싱 중단 시간 짧음

✅ 📌 마지막으로 도입된 6.5 정확히 한 번(Exactly Once) 컨슈머 동작
Producer 쪽에서 다룬 정확히 한 번 전송과 연계.
