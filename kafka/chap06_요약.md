# 📚 6장 Kafka 컨슈머 내부 동작 원리와 구현 요약

## ✅ 6.1 컨슈머 오프셋 관리

- 컨슈머의 핵심 역할은 **메시지를 어디까지 읽었는지 기억**하는 것.
- 읽은 위치 정보(오프셋)는 `_consumer_offsets`라는 내부 토픽에 저장.
- 컨슈머 장애로 중단되었다가 재시작해도 마지막 오프셋부터 이어서 처리 가능.
- 오프셋 정보는 **토픽, 파티션, 컨슈머 그룹** 단위로 관리됨.
- `_consumer_offsets` 토픽의 파티션/복제 수는 `server.properties`에서 설정.
  - `offsets.topic.num.partitions`: 기본 50
  - `offsets.topic.replication.factor`: 기본 3

## ✅ 6.2 그룹 코디네이터

- 컨슈머 그룹은 **그룹 코디네이터**가 파티션 할당과 멤버 상태를 관리.
- 그룹에 컨슈머가 추가/제거되면 `리밸런싱(rebalancing)`이 발생.
- 컨슈머는 하트비트(heartbeat)를 주기적으로 보내 코디네이터가 상태를 확인.
- 불필요한 리밸런싱을 줄이려면 스태틱 멤버십 등을 사용.

## ✅ 6.3 스태틱 멤버십

- 컨슈머가 재시작될 때 **동일한 ID로 인식**되어 리밸런싱 방지.
- 기본 리밸런싱은 컨슈머 종료 시마다 전체 파티션 할당을 다시 수행.
- 스태틱 멤버십은 대량 데이터 처리 시 효율적.
- 설정:
  - `group.instance.id`: 멤버 고유 ID
  - `session.timeout.ms`: 재시작 시 리밸런싱 시점 조정

## ✅ 6.4 컨슈머 파티션 할당 전략

### 🔹 지원 전략과 특징

| 전략 | 설명 |
|--|--|
| **Range** | 파티션 할당 전략의 기본값으로서 토픽별로 할당 전략을 사용함. 동일한 키를 이용하는 2개 이상의 토픽을 컨슘할 때 유용 |
| **Round-Robin** | 사용 가능한 파티션과 컨슈머들을 라운드 로빈으로 할당함. 균등한 분배 가능 |
| **Sticky** | 컨슈머가 컨슘하고 있는 파티션을 계속 유지할 수 있음 |
| **Cooperative Sticky** | 스티키 방식과 유사하지만, 전체 일시 정지가 아닌 연속적인 재조정 방식 |

## ✅ 6.5 정확히 한 번 컨슈머 동작

- 프로듀서 측은 트랜잭션 ID로 **정확히 한 번 전송(Exactly Once)**.
- 컨슈머 측은 메시지를 처리 후 오프셋을 commit → 중복 방지.
- `enable.idempotence` 옵션을 통해 중복 방지 기능 활성화.
