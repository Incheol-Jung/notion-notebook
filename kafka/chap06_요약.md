# 📚 6장 Kafka 컨슈머 내부 동작 원리와 구현 요약

## ✅ 6.1 컨슈머 오프셋 관리

- 컨슈머의 핵심 역할은 **메시지를 어디까지 읽었는지 기억**하는 것.
- 읽은 위치 정보(오프셋)는 `_consumer_offsets`라는 내부 토픽에 저장.
- 컨슈머 장애로 중단되었다가 재시작해도 마지막 오프셋부터 이어서 처리 가능.
- 오프셋 정보는 **토픽, 파티션, 컨슈머 그룹** 단위로 관리됨.
- `_consumer_offsets` 토픽의 파티션/복제 수는 `server.properties`에서 설정.
  - `offsets.topic.num.partitions`: 기본 50
  - `offsets.topic.replication.factor`: 기본 3

## ✅ 6.2 그룹 코디네이터

- 컨슈머 그룹은 **그룹 코디네이터**가 파티션 할당과 멤버 상태를 관리.
- 그룹에 컨슈머가 추가/제거되면 `리밸런싱(rebalancing)`이 발생.
- 컨슈머는 하트비트(heartbeat)를 주기적으로 보내 코디네이터가 상태를 확인.
- 불필요한 리밸런싱을 줄이려면 스태틱 멤버십 등을 사용.

## ✅ 6.3 스태틱 멤버십

- 컨슈머가 재시작될 때 **동일한 ID로 인식**되어 리밸런싱 방지.
- 기본 리밸런싱은 컨슈머 종료 시마다 전체 파티션 할당을 다시 수행.
- 스태틱 멤버십은 대량 데이터 처리 시 효율적.
- 설정:
  - `group.instance.id`: 멤버 고유 ID
  - `session.timeout.ms`: 재시작 시 리밸런싱 시점 조정

## ✅ 6.4 컨슈머 파티션 할당 전략

### 🔹 지원 전략과 특징 (표 6-1)

| 전략 | 설명 |
|||
| **Range** | 파티션을 순서대로 정렬해 컨슈머에 나눔. 일부 편중 가능 |
| **Round-Robin** | 모든 파티션을 순서대로 컨슈머에 돌아가며 균등 분배 |
| **Sticky** | 기존 파티션 할당을 최대한 유지 |
| **Cooperative Sticky** | Sticky + 일부만 재할당. EAGER보다 효율적 |

## ✅ 6.5 정확히 한 번 컨슈머 동작

- 프로듀서 측은 트랜잭션 ID로 **정확히 한 번 전송(Exactly Once)**.
- 컨슈머 측은 메시지를 처리 후 오프셋을 commit → 중복 방지.
- `enable.idempotence` 옵션을 통해 중복 방지 기능 활성화.
