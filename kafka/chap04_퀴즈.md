# ✅ [4장] 연습문제

## 1. 컨슈머 그룹의 오프셋 정보는 어디에 저장되는가?
① _consumer_log ② _offset ③ _consumer_offset ④ _kafka_offset

정답: 3

## 2. 로그 컴팩션의 주요 목적은?
① 전체 메시지 삭제 ② 최신 데이터만 유지 ③ 모든 데이터를 보관 ④ 토픽 삭제

정답: 2

## 3. 다음 중 로그 컴팩션이 적합한 예는?
① 과거 주문 내역 전체 보관
② 실시간 로그 분석용 메시지
③ 사용자 현재 상태 값 유지
④ 대용량 파일 저장

정답: 3

## 4. 로그 컴팩션 동작 시 기준은?
① 밸류 ② 키 ③ 토픽 이름 ④ 오프셋

정답: 2

## 5. 로그 컴팩션 설정 옵션 중 cleanup.policy의 값은?
① delete ② retain ③ compact ④ overwrite

정답: ③

## 6. log.cleaner.min.cleanable.ratio는 무엇을 설정하는가?
① 최대 배치 크기 ② 로그 지연 시간 ③ 청소 비율 ④ 오프셋 복구

정답: ③

## 7. 카프카에서 신뢰성을 유지하려면 무엇을 반드시 모니터링해야 하나?
① 클러스터 CPU 사용량 ② 리소스 모니터링 ③ 컨슈머 그룹 수 ④ 토픽 개수

정답: ②

## 8. Kafka에서 리더에포크(LeaderEpoch)의 주된 역할은?
1. 컨슈머의 커밋 오프셋을 저장한다
2. 리더와 팔로워 간 메시지 일관성을 유지한다
3. 브로커의 네트워크 트래픽을 모니터링한다
4. ISR 그룹을 갱신한다

✅ 정답: 2 <br/>
💡 설명: 리더에포크는 리더 변경 시 팔로워가 안전한 복구 지점을 파악할 수 있도록 도와 메시지 손실을 방지한다.

## 9. 리더에포크가 없으면 발생할 수 있는 문제는?
1. 프로듀서가 메시지를 중복 전송한다
2. 리더와 팔로워 간 하이워터마크 불일치로 메시지 손실이 발생한다
3. 컨슈머가 ISR 그룹을 잃는다
4. 브로커가 자동으로 오프셋을 초기화한다

✅ 정답: 2 <br/>
💡 설명: 리더에포크 없이 복구하면 메시지 동기화 충돌로 일부 데이터가 삭제되거나 손실될 수 있다.

## 10. 리더에포크는 어떻게 관리되는가?
1. 프로듀서가 관리한다
2. 컨슈머가 수동으로 설정한다
3. 컨트롤러가 관리하며 리더 변경 시 1씩 증가한다
4. 팔로워가 직접 값을 설정한다

✅ 정답: 3 <br/>
💡 설명: Kafka 컨트롤러가 리더 변경마다 리더에포크를 관리하고 값을 갱신한다.

## 11. 장애 복구 시 리더에포크를 사용하는 팔로워의 동작으로 옳은 것은?
1. 리더에포크 요청을 리더에 보낸다
2. 하이워터마크보다 높은 메시지를 무조건 삭제한다
3. 새 리더를 무조건 거부한다
4. ISR 그룹을 종료한다

✅ 정답: 1 <br/>
💡 설명: 팔로워는 리더에 리더에포크를 요청해 안전한 복구 오프셋을 확인한다.

## 12. 그림 4-11 ~ 4-13의 비교에서 리더에포크 사용 시 장점은?
1. 메시지 복제가 더 느려진다
2. 하이워터마크를 무조건 0으로 리셋한다
3. 필요 없는 메시지 삭제를 피할 수 있다
4. 프로듀서의 작업량이 늘어난다

✅ 정답: 3 <br/>
💡 설명: 리더에포크로 안전한 오프셋만 동기화해 불필요한 삭제를 방지할 수 있다.

## 13. 리더에포크 값이 증가한다는 것은?
1. 새로운 팔로워가 추가되었다는 의미
2. 리더가 교체되었다는 의미
3. 컨슈머가 재시작되었다는 의미
4. 브로커 로그가 삭제되었다는 의미

✅ 정답: 2 <br/>
💡 설명: 리더 교체 시마다 리더에포크가 1씩 증가해 변경 이력을 기록한다.

## 14. [주관식] 로그 컴팩션이 필요한 상황을 하나 예로 들어보세요.
예시답: 사용자 배송 상태처럼 최신 상태만 유지하면 되는 데이터.

## 15. [주관식] 컨슈머 그룹의 오프셋을 커밋하지 않으면 발생할 수 있는 문제는?
예시답: 메시지를 중복 소비하거나 메시지를 잃어버릴 수 있음.

## 16. [주관식] 카프카의 신뢰성 보장을 위해 중요한 핵심은?
예시답: 오프셋 관리와 로그 컴팩션으로 불필요한 데이터 제거와 최신 상태 유지.
