# ✅ Kafka 리더-팔로워 구조 객관식 문제 (10문항)
## 🔹 1. Kafka에서 **리더(Leader)**의 주요 역할로 올바른 것은?
데이터를 읽고 쓰는 연산을 주로 담당한다.

데이터를 복제하여 다른 브로커로 전송한다.

컨슈머로부터 메시지를 읽는다.

프로듀서로부터 메시지를 가져와 저장하지 않는다.

✅ 정답: 1
📝 해설: 리더는 프로듀서의 데이터를 받아 저장하고, 컨슈머가 읽을 수 있도록 제공한다.

## 🔹 2. Kafka에서 **팔로워(Follower)**의 역할로 올바른 것은?
새로운 메시지를 직접 프로듀서에게 받는다.

리더의 데이터를 복제하여 저장한다.

컨슈머에게 데이터를 직접 제공한다.

리더 없이 독립적으로 동작한다.

✅ 정답: 2
📝 해설: 팔로워는 리더의 데이터를 복제하여 장애 시 데이터 무결성을 보장한다.

## 🔹 3. **ISR(In-Sync Replica)**에 대한 설명으로 옳은 것은?
모든 팔로워는 항상 ISR에 포함된다.

ISR에 속하지 않은 팔로워도 리더로 승격될 수 있다.

리더와 데이터가 동기화된 팔로워들의 그룹이다.

ISR은 리더 선출과 무관하다.

✅ 정답: 3
📝 해설: ISR은 리더와 동기화된 복제본들로만 구성되어, 장애 시 안전한 리더 선출이 가능하다.

## 🔹 4. Kafka의 **커밋(high water mark)**의 의미로 올바른 것은?
컨슈머가 읽을 수 있는 마지막 메시지의 위치이다.

팔로워가 리더의 메시지를 저장하는 첫 위치이다.

프로듀서가 보낸 메시지의 오프셋이다.

리더가 팔로워에게 메시지를 보내는 속도이다.

✅ 정답: 1
📝 해설: 커밋 위치는 ISR 내 모든 복제가 끝난 메시지까지를 나타내며, 컨슈머는 그 위치까지의 메시지만 읽을 수 있다.

## 🔹 5. Kafka에서 리더 장애 시 수행되는 과정으로 옳은 것은?
팔로워 중 ISR에 속하지 않아도 아무나 리더로 승격된다.

리더 장애 시 데이터 일관성은 보장되지 않는다.

ISR에 속한 팔로워 중 하나가 새로운 리더가 된다.

장애 시 새로운 파티션을 생성한다.

✅ 정답: 3
📝 해설: ISR 그룹은 리더 장애 시 안전하게 리더로 승격될 수 있는 복제본으로 구성된다.

## 🔹 6. Kafka가 리더와 팔로워 간 ACK 통신을 최소화한 이유는?
성능을 높이기 위해서

데이터 무결성을 포기하기 위해서

컨슈머의 속도를 낮추기 위해서

ISR 그룹 관리를 단순화하기 위해서

✅ 정답: 1
📝 해설: 리더가 모든 메시지마다 팔로워에게 ACK를 주면 성능이 크게 떨어지기 때문에, Kafka는 ACK 통신을 최소화해 효율성을 높인다.

## 🔹 7. 리더와 팔로워의 Replication Offset Checkpoint 파일의 역할은?
리더와 팔로워의 메시지 내용 암호화

마지막 복제 위치를 기록

컨슈머가 읽은 메시지 기록

ISR 그룹 여부를 표시

✅ 정답: 2
📝 해설: 이 파일은 디스크에 마지막 커밋된 오프셋을 저장해 장애 복구 시 복제 위치를 확인할 수 있도록 한다.

## 🔹 8. Kafka에서 컨슈머가 읽을 수 없는 메시지는?
커밋된 메시지

리더에만 저장된 메시지

팔로워에 저장된 메시지

ISR 그룹에 저장된 메시지

✅ 정답: 2
📝 해설: 컨슈머는 반드시 커밋된 메시지만 읽을 수 있다. 리더에만 저장되고 팔로워에 복제되지 않은 메시지는 읽을 수 없다.

## 🔹 9. 아래 중 Kafka의 리더 선출 과정에 대한 설명으로 올바른 것은?
리더는 항상 고정되어 바뀌지 않는다.

리더 장애 시 무조건 새로운 파티션이 생성된다.

ISR에 속한 팔로워 중 하나가 새로운 리더로 승격된다.

팔로워는 리더로 승격될 수 없다.

✅ 정답: 3
📝 해설: 리더 장애가 발생하면 ISR에 속한 팔로워 중 하나가 안전하게 리더로 승격된다.

## 🔹 10. Kafka가 리더와 팔로워 간의 리플리케이션 구조를 사용하는 이유는?
데이터 복제 없이 성능을 높이기 위해서

장애 발생 시 데이터 손실 방지와 무중단 처리를 위해서

컨슈머 수를 줄이기 위해서

프로듀서의 데이터를 직접 컨슈머로 보내기 위해서

✅ 정답: 2
📝 해설: 리더와 팔로워 구조는 장애가 발생해도 복제된 데이터를 통해 안정성을 유지하고, 무중단 서비스를 가능하게 한다.

